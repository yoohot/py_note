### 函数
  函数也是一个对象，对象是内存中专门存储数据的一块区域。
  def method_name([param[,params...]]) (-> int这个也是提示描述用，非强制) :
        method_body#函数中也可以定义函数

 定义形参时,可指定默认值,这样在调用时可以不传实参,也可以指定类型：int,但是不传int也可以
 这里只是给调用者提示 c:int=10
 关键字传参，可以不按照形参顺序传参，而是直接使用形参名称取传参
 eg cal(c=10：int,a=2,b=20),位置参数和关键字参数可以混合使用，位置参数必须在前
 不定长参数：形参前加 * ，会用一个元组来保存所有的实参，接受0个或多个实参,方法中只能有
 一个可变形参*，不是必须写在最后，但可变参数后的其他参数必须根据形参名传递
 两个**形参:可以接受没有定义名字但是传递时有名的参数，保存到字典dict中
  eg: fn(a,** b)  fn(a=1,e=2,c=10)  **形参只能有一个，且必须写在最后
 返回值:直接return，可以return任意对象(包括函数),函数最后只有一个return或者没有return
       相当于直接return None;return执行完函数结束
 文档字符串:在函数的第一行字符串就是文档字符串，作为函数说明，或者'''可换行'''
 help()：为内置函数，可以查看其他函数的用法和文档字符串
 作用域：python有两种作用域，全局作用域和函数作用域；所有函数以外的都属于全局作用域
       局部变量优先级>上一级作用域的变量优先级
       默认情况 函数中 a=10，并不会改变上一级变量a，这里的a时局部变量,如果希望修改全局
       可以使用global关键字：  global a   a=100
命名空间：变量存储的位置，每一个变量都需要存储到指定的命名空间中；每一个作用域都会有一个
        它对应的命名空间；命名空间实际上就是一个存储变量的字典
        locals():获取当前作用域的命名空间;可以直接向这个字典中添加key:value来声明变量
        globals():任意地方获取全局的命名空间
高阶函数：符合以下两个特点中的一个：
        1接受一个或多个函数作为参数
        2将函数作为返回值返回 - 闭包
匿名函数：lambda 参数列表 : 返回值
          eg: fn = lambda a,b : a+b
              sum(10,20,lambda a,b : a*b)
        filter(函数,可迭代序列)：参数函数对每个元素过滤
        map(函数,可迭代序列)：参数函数对每个元素操作
        列表的sort()：可以传一个函数参数，参数名key
        sorted():类似sort，可以对任意序列排序并返回，不影响原来对象
装饰器：     
   def 装饰器方法dec(fn) :
    def fun(*args,**margs) :
      代码块
      fn(*args,**margs) ##这里时拆包
      代码块   
   return fun

  @dec #标注这个方法需要被装饰；可以有多个装饰器
  def 被装饰fn_name(params) :
   ...


### 类 class
 class ClassName[([父类])] :
   公共属性  # 可不定义,对象使用时在指定属性
   #执行类中的代码(只执行一次，类似java的静态代码块)

   def __init__(self,... : #魔术方法。类似java构造方法，生成对象时被调用。
                           #对象可直接调用(不用),self 后的参数需要由创建时传入
        ...
   def method_name(self) :
      ...

类属性：直接在类里定义的属性,可以不定义,在对象中直接指派值；class.xxx=XX这是修改类属性
实例属性,通过实例添加的属性对象.xxx = X
int() float() bool() str() list() dict() 这些都是类，只是没有大写
isinstance(x,clazz):用来检查是否是类或该类子类的实例
类也是一个对象,是一个用来创建对象的对象,类是type类型的对象,定义类实际上就是定义一个type
对象
实例方法：第一个参数由解析器自动传递，所以定义时至少要定义一个形参，这个参时是对象本身
实例方法可以通过类调用，这时第一个参数-对象需要传入
类方法：@classmethod修饰的方法,类方法的第一个参数cls也是会被自动传入，就是当前类对象,
类方法可以通过类调用，也可以通过实例调用
静态方法：@staticmethod修饰的方法，静态方法不需要指定任何默认参数。可以通过类/实例调用
创建对象流程：
 1创建一个变量
 2内存中创建一个对象
 3执行魔术方法 init
 4对象id赋值给变量

####封装：
 将属性民取一个特殊的名称，并提供getter/setter方法设置查询属性值；eg:name ->
  _name ,get_name / set_name
 @property装饰器,为了简化get_propertyName()方法，直接将getter方法命名为property()
   方法，并且加上 @property装饰器，使用getter方法时直接 对象.property即可。这个装饰器
将getter方法隐藏，直接返回property，而且这种不能直接对象.property=XXX 保证安全
 eg
     @property
     def name(self) :
       return self._name
@属性名.setter装饰器,就可以直接对象.property=XXX setter装饰器前提是必须由getter装饰器
    eg‘
      @name.setter
      def name(self,name) :
        self._name=name

#### 继承：
通过继承可以获取到其他类中所有的属性和方法,定义类时,可以在类后面括号中指定父类。默认继承
object类。object所有类的父类
issubclass(clazz,clazz):
父类中所有的方法都会被继承，包括特殊方法,可以重写这些方法：init被子类覆盖不会再自动执行
super():获取当前类的父类，可以在__init__方法中：super().__init(params)__
多重继承：python中可同时继承多父类（A,B）,类名.__bases__这个属性可以来查看类的所有父类
应尽量避免多重继承。若父类中有同名方法，则会按继承先后顺序寻找。若父类，没有,则找父类的父
类，直到object没有就寻找该类的下一个继承的父类

#### 多态
len函数：原理，只要对象的类中有__len__()特殊方法，就都可以被len函数调用

### 垃圾回收
python有自动垃圾回收机制
__def__(self): 也是一个特殊方法，会在对象被回收前被调用

### 特殊方法
__开始和结束的方法，是自动执行的方法
__str__(self):类似java toString()
__repr__(self):使用repr()调用时使用,repr在交互模式中输出的效果
__eq__(self,other):比较 == 时使用，类似lt le eq ne gt ge
__len__(self):len()函数调用时
__bool__(self):bool()函数调用时
...算法运算等